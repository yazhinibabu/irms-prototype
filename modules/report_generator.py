"""
Report generation module
"""
from datetime import datetime
from pathlib import Path
from typing import Dict, List


class ReportGenerator:
    """Generates comprehensive release management reports."""
    
    def __init__(self, output_dir: Path):
        """
        Initialize report generator.
        
        Args:
            output_dir: Directory for report output
        """
        self.output_dir = output_dir
    
    def generate_comprehensive_report(
        self,
        user_query: str,
        ingestion_summary: Dict,
        analysis_results: Dict[str, Dict],
        ai_results: Dict[str, Dict],
        change_results: Dict[str, Dict],
        risk_assessments: Dict[str, Dict],
        overall_risk: Dict
    ) -> str:
        """
        Generate a comprehensive markdown report.
        
        Returns:
            Path to generated report file
        """
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        report_filename = f"IRMS_Report_{timestamp}.md"
        report_path = self.output_dir / report_filename
        
        # Build report content
        report = self._build_report_content(
            user_query,
            ingestion_summary,
            analysis_results,
            ai_results,
            change_results,
            risk_assessments,
            overall_risk
        )
        
        # Write report
        with open(report_path, 'w', encoding='utf-8') as f:
            f.write(report)
        
        return str(report_path)
    
    def _build_report_content(
        self,
        user_query: str,
        ingestion_summary: Dict,
        analysis_results: Dict,
        ai_results: Dict,
        change_results: Dict,
        risk_assessments: Dict,
        overall_risk: Dict
    ) -> str:
        """Build the complete report content."""
        
        report_lines = [
            "# Intelligent Release Management Scanner (IRMS)",
            "## Release Analysis Report\n",
            f"**Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"**Status:** {self._get_status_emoji(overall_risk.get('overall_gate_decision', 'WARN'))} {overall_risk.get('overall_gate_decision', 'PENDING')}\n",
            "---\n",
            "## Executive Summary\n",
            f"**User Request:** {user_query}\n",
            f"**Files Analyzed:** {len(analysis_results)}",
            f"**Overall Risk Score:** {overall_risk.get('average_risk_score', 0)}/100",
            f"**Gate Decision:** {overall_risk.get('overall_gate_decision', 'PENDING')}\n"
        ]
        
        # Gate counts
        gate_counts = overall_risk.get('gate_counts', {})
        report_lines.extend([
            "**Gate Breakdown:**",
            f"- âœ“ PASS: {gate_counts.get('PASS', 0)} files",
            f"- âš  WARN: {gate_counts.get('WARN', 0)} files",
            f"- â›” BLOCK: {gate_counts.get('BLOCK', 0)} files\n",
            "---\n"
        ])
        
        # Ingestion summary
        report_lines.extend([
            "## Input Sources\n",
            f"**Python Files Ingested:** {len(ingestion_summary.get('python_files', []))}",
            "```"
        ])
        for pf in ingestion_summary.get('python_files', []):
            report_lines.append(f"  - {pf}")
        report_lines.append("```\n")
        
        report_lines.append(f"**Documentation Files:** {len(ingestion_summary.get('documents', []))}")
        report_lines.append("```")
        for doc in ingestion_summary.get('documents', []):
            report_lines.append(f"  - {doc}")
        report_lines.append("```\n")
        report_lines.append("---\n")
        
        # Detailed analysis for each file
        report_lines.append("## Detailed File Analysis\n")
        
        for filename in analysis_results.keys():
            report_lines.extend(
                self._build_file_section(
                    filename,
                    analysis_results.get(filename, {}),
                    ai_results.get(filename, {}),
                    change_results.get(filename, {}),
                    risk_assessments.get(filename, {})
                )
            )
        
        # Overall recommendations
        report_lines.extend([
            "---\n",
            "## Overall Recommendations\n"
        ])
        
        all_recommendations = set()
        for assessment in risk_assessments.values():
            all_recommendations.update(assessment.get('recommendations', []))
        
        for i, rec in enumerate(sorted(all_recommendations), 1):
            report_lines.append(f"{i}. {rec}")
        
        report_lines.extend([
            "\n---\n",
            "## Conclusion\n",
            self._build_conclusion(overall_risk),
            "\n---\n",
            "*Report generated by Intelligent Release Management Scanner (IRMS)*"
        ])
        
        return '\n'.join(report_lines)
    
    def _build_file_section(
        self,
        filename: str,
        analysis: Dict,
        ai_result: Dict,
        changes: Dict,
        risk: Dict
    ) -> List[str]:
        """Build report section for a single file."""
        section = [
            f"### ğŸ“„ {filename}\n",
            f"**Risk Score:** {risk.get('risk_score', 0)}/100",
            f"**Gate Decision:** {self._get_status_emoji(risk.get('gate_decision', 'WARN'))} {risk.get('gate_decision', 'PENDING')}\n"
        ]
        
        # Static analysis
        section.extend([
            "#### Original Code Analysis\n",
            f"- **Lines of Code:** {analysis.get('metrics', {}).get('lines', {}).get('code', 0)}",
            f"- **Maintainability Index:** {analysis.get('metrics', {}).get('maintainability_index', 0)}",
            f"- **Average Complexity:** {analysis.get('complexity', {}).get('average', 0)}",
            f"- **Issues Found:** {len(analysis.get('issues', []))}\n"
        ])
        
        # Issues
        issues = analysis.get('issues', [])
        if issues:
            section.append("**Key Issues:**")
            for issue in issues[:5]:  # Show top 5
                section.append(f"- Line {issue['line']}: {issue['message']} ({issue['severity']})")
            if len(issues) > 5:
                section.append(f"- ... and {len(issues) - 5} more issues\n")
        else:
            section.append("**No issues detected**\n")
        
        # AI Changes
        section.extend([
            "#### Changes Applied\n",
            ai_result.get('explanation', 'No changes applied')+'\n'
        ])
        
        if ai_result.get('changes_made'):
            section.append("**Specific Changes:**")
            for change in ai_result.get('changes_made', []):
                section.append(f"- {change}")
            section.append("")
        
        # Change statistics
        stats = changes.get('statistics', {})
        section.extend([
            "#### Change Statistics\n",
            f"- Lines Added: +{stats.get('lines_added', 0)}",
            f"- Lines Deleted: -{stats.get('lines_deleted', 0)}",
            f"- Lines Modified: ~{stats.get('lines_modified', 0)}",
            f"- Total Changes: {stats.get('total_changes', 0)}\n"
        ])
        
        # Risk components
        risk_components = risk.get('risk_components', {})
        section.extend([
            "#### Risk Breakdown\n",
            f"- Complexity Risk: {risk_components.get('complexity_risk', 0)}%",
            f"- Change Volume Risk: {risk_components.get('change_volume_risk', 0)}%",
            f"- Critical Function Risk: {risk_components.get('critical_function_risk', 0)}%",
            f"- Issue Severity Risk: {risk_components.get('issue_severity_risk', 0)}%\n"
        ])
        
        # Recommendations
        recommendations = risk.get('recommendations', [])
        if recommendations:
            section.append("**Recommendations:**")
            for rec in recommendations:
                section.append(f"- {rec}")
        
        section.append("\n---\n")
        
        return section
    
    def _build_conclusion(self, overall_risk: Dict) -> str:
        """Build conclusion section based on overall risk."""
        decision = overall_risk.get('overall_gate_decision', 'WARN')
        risk_score = overall_risk.get('average_risk_score', 0)
        
        if decision == 'PASS':
            return f"""
The changes have been analyzed and deemed **low risk** (score: {risk_score}/100). 
The modified code is recommended for the next release stage with standard review procedures.

**Next Steps:**
1. Review the modified code files
2. Run automated test suites
3. Proceed with deployment pipeline
"""
        elif decision == 'WARN':
            return f"""
The changes have been flagged with **medium risk** (score: {risk_score}/100).
Additional review and testing are recommended before proceeding to the next release stage.

**Next Steps:**
1. Conduct thorough code review
2. Run comprehensive test suites
3. Address highlighted recommendations
4. Re-assess before deployment
"""
        else:  # BLOCK
            return f"""
The changes have been identified as **high risk** (score: {risk_score}/100).
The release is **blocked** and requires immediate attention before proceeding.

**Required Actions:**
1. Address all critical issues
2. Refactor high-complexity areas
3. Add comprehensive test coverage
4. Conduct security review if applicable
5. Re-run IRMS analysis after fixes
"""
    
    def _get_status_emoji(self, decision: str) -> str:
        """Get emoji for gate decision."""
        emojis = {
            'PASS': 'âœ…',
            'WARN': 'âš ï¸',
            'BLOCK': 'ğŸ›‘',
            'PENDING': 'â³'
        }
        return emojis.get(decision, 'â“')
